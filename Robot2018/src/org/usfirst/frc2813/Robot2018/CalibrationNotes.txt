Calibration Notes: a checklist for gameday code changes

The surface of each playing field is likely to be unique, and different from the tile floors we've been test-driving on. We should have a straightforward process for calibrating our code to the empirical reality of each playing field.

PIDAutoDrive.java: the ACCELERATION and DECELERATION constants may need to be adjusted since competition floors are likely to be less slick than the cafeteria floor.

AutonomousCommandGroupGenerator.java: the turning angle may need to be adjusted. (If inertia takes the robot more than the specified 90 degrees, we may want to set it to 80 degrees or whatever corresponds, empirically, to 90 degrees on the competition game field.)

AutonomousCommandGroupGenerator.java: we may want to add wait commands between other commands, especially turn commands. (If the robot is still moving or turning from its previous command, resetting encoders and gyros may not behave as anticipated.)


A quick calibration test run might look something like this: (the equations to determine the acceleration/deceleration constants assume driveSpeed has been set at 0.5 for the test, although the resulting constants should work for all driveSpeed values.)

  I. Find linear interpolation ACCELERATION and DECELERATION parameters
     A. Confirm encoder accuracy with one slow run:
        - set AutonomousCommandGroup's driveSpeed to 0.5
        - set ACCELERATION to a very large value like 250
        - set DECELERATION to a very large value like 250
        - drive a straight path like autoCmdList.driveForward(120)
        - measure distance D1 (which should be close to 120 inches)
     B. Find acceleration slip by starting quickly:
        - set AutonomousCommandGroup's driveSpeed to 0.5
        - set ACCELERATION to 10 (for very quick acceleration, presumably slipping)
        - set DECELERATION to 250 (for slow deceleration)
        - drive a straight path like autoCmdList.driveForward(120)
        - measure distance D2 (which will probably be smaller than D1)
     C. Find deceleration slip by stopping quickly:
        - set AutonomousCommandGroup's driveSpeed to 0.5
        - set ACCELERATION to 250 (for slow acceleration: it will reach driveSpeed == 0.5 at 94 inches)
        - set DECELERATION to 10 (for very quick deceleration, presumably slipping)
        - drive a straight path like autoCmdList.driveForward(120)
        - measure distance D3 (which will probably be larger than D1)
     D. Determine ACCELERATION and DECELERATION from measured D1, D2, and D3
        - ACCELERATION = (D1-D2)/(0.5-0.2)*(1.0-0.2) = (D1-D2)*(8/3)
        - DECELERATION = (D3-D1)/(0.5-0.2)*(1.0-0.2) = (D3-D1)*(8/3)
     E. Possibly fudge the values by increasing them a little, because we don't want to be
        right on the bleeding edge of the static vs. dynamic coefficient of friction.
 II. Find turning angles
     A. Find 90-degree slip
        - execute autoCmdList.turnRight(90), wait for robot to settle
        - execute autoCmdList.turnRight(90), wait for robot to settle
        - execute autoCmdList.turnRight(90), wait for robot to settle
        - execute autoCmdList.turnRight(90), wait for robot to settle
        - measure error, divide by four, update autonomous code accordingly
     B. Find 45-degree slip
        - execute autoCmdList.turnRight(45), wait for robot to settle
        - execute autoCmdList.turnRight(45), wait for robot to settle
        - execute autoCmdList.turnRight(45), wait for robot to settle
        - execute autoCmdList.turnRight(45), wait for robot to settle
        - measure error, divide by four, update autonomous code accordingly
     C. Probably repeat for turning the other direction

