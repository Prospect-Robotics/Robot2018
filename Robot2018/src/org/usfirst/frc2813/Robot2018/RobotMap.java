// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2813.Robot2018;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
//import edu.wpi.first.wpilibj.WPI_VictorSPX;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static WPI_VictorSPX driveTrainSpeedController1;// Port Motor
	public static WPI_VictorSPX driveTrainSpeedController2;// Starboard Motor
	public static VictorSPX driveTrainSpeedController11;
	public static VictorSPX driveTrainSpeedController22;
	public static DifferentialDrive driveTrainRobotDrive;
	public static Encoder driveTrainQuadratureEncoder1;// Starboard Motor
	public static Encoder driveTrainQuadratureEncoder2;// Port Motor
	public static Encoder driveTrainQuadratureEncoder11;
	public static Encoder driveTrainQuadratureEncoder22;
	public static Solenoid driveTrainSolenoid1;
	public static WPI_VictorSPX elevatorSpeedController1;
	public static WPI_VictorSPX elevatorSpeedController2;
	public static VictorSPX elevatorSpeedController11;
	public static VictorSPX elevatorSpeedController22;
	public static SpeedController intakeSpeedController1;
	public static SpeedController intakeSpeedController2;
	public static Encoder elevatorQuadratureEncoder1;
	public static DigitalInput elevatorDigitalInput1;
	public static SpeedController armSpeedController1;
	public static Encoder armQuadratureEncoder1;
	public static DigitalInput armDigitalInput1;
	private static final double WHEEL_DIAMETER = 4;
	public static final double WHEEL_CIRCUMFERENCE = Math.PI * WHEEL_DIAMETER;
	//public static final double REVOLUTIONS_PER_INCH = 1.0 / WHEEL_CIRCUMFERENCE;
	public static final double PULSES_PER_REVOLUTION = 256; // it should be 256 but the robot only % as far as it should with 256
	//public static final double PULSES_PER_INCH = PULSES_PER_REVOLUTION * REVOLUTIONS_PER_INCH;goes ~80
	public static final double INCHES_PER_PULSE = WHEEL_CIRCUMFERENCE / PULSES_PER_REVOLUTION; // inches per revolution times revolutions per pulse (1/pulses per revolution) equals inches per pulse.

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	@SuppressWarnings("deprecation")
	public static void init() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		driveTrainSpeedController1 = new WPI_VictorSPX(1);
		driveTrainSpeedController1.setName("DriveTrain", "Port Motor");
		driveTrainSpeedController1.setInverted(false);
		LiveWindow.add(driveTrainSpeedController1);
		driveTrainSpeedController2 = new WPI_VictorSPX(7);
		driveTrainSpeedController2.setName("DriveTrain", "Starboard Motor");
		driveTrainSpeedController2.setInverted(false);
		LiveWindow.add(driveTrainSpeedController2);

		driveTrainSpeedController11 = new VictorSPX(2);
		driveTrainSpeedController11.set(ControlMode.Follower, driveTrainSpeedController1.getDeviceID());
		driveTrainSpeedController11.setInverted(driveTrainSpeedController1.getInverted());
		driveTrainSpeedController22 = new VictorSPX(8);
		driveTrainSpeedController22.set(ControlMode.Follower, driveTrainSpeedController2.getDeviceID());
		driveTrainSpeedController22.setInverted(false);

		// driveTrainSpeedController3 = new PWMVictorSPX(2);
		// LiveWindow.addActuator("DriveTrain", "Speed Controller 3", (PWMVictorSPX)
		// driveTrainSpeedController3);
		// driveTrainSpeedController3.setInverted(false);
		// driveTrainSpeedController4 = new PWMVictorSPX(3);
		// LiveWindow.addActuator("DriveTrain", "Speed Controller 4", (PWMVictorSPX)
		// driveTrainSpeedController4);
		// driveTrainSpeedController4.setInverted(false);
		driveTrainRobotDrive = new DifferentialDrive(driveTrainSpeedController1, driveTrainSpeedController2);
		LiveWindow.add(driveTrainRobotDrive);
		// driveTrainSpeedController3, driveTrainSpeedController4);

		driveTrainRobotDrive.setSafetyEnabled(true);
		driveTrainRobotDrive.setExpiration(0.1);
		// driveTrainRobotDrive.setSensitivity(0.5);
		driveTrainRobotDrive.setMaxOutput(1.0);

		driveTrainQuadratureEncoder1 = new Encoder(10, 11, true, EncodingType.k4X);// port 0 2*0+10=10, port 0 2*0+11=11
		LiveWindow.addSensor("DriveTrain", "Quadrature Encoder 1", driveTrainQuadratureEncoder1);
		driveTrainQuadratureEncoder1.setDistancePerPulse(INCHES_PER_PULSE);
		driveTrainQuadratureEncoder1.setSamplesToAverage(1);
		driveTrainQuadratureEncoder1.setPIDSourceType(PIDSourceType.kRate);
		driveTrainQuadratureEncoder2 = new Encoder(12, 13, true, EncodingType.k4X);
		driveTrainQuadratureEncoder2.setReverseDirection(true);
		LiveWindow.addSensor("DriveTrain", "Quadrature Encoder 2", driveTrainQuadratureEncoder2);
		driveTrainQuadratureEncoder2.setDistancePerPulse(INCHES_PER_PULSE);
		driveTrainQuadratureEncoder2.setSamplesToAverage(1);
		driveTrainQuadratureEncoder2.setPIDSourceType(PIDSourceType.kRate);
		// driveTrainQuadratureEncoder3 = new Encoder(4, 5, true, EncodingType.k4X);
		// LiveWindow.addSensor("DriveTrain", "Quadrature Encoder 3",
		// driveTrainQuadratureEncoder3);
		// driveTrainQuadratureEncoder3.setDistancePerPulse(1.0);
		// driveTrainQuadratureEncoder3.setPIDSourceType(PIDSourceType.kRate);
		// driveTrainQuadratureEncoder4 = new Encoder(6, 7, true, EncodingType.k4X);
		// LiveWindow.addSensor("DriveTrain", "Quadrature Encoder 4",
		// driveTrainQuadratureEncoder4);
		// driveTrainQuadratureEncoder4.setDistancePerPulse(1.0);
		// driveTrainQuadratureEncoder4.setPIDSourceType(PIDSourceType.kRate);
		driveTrainSolenoid1 = new Solenoid(0, 0);
		LiveWindow.addActuator("DriveTrain", "Solenoid 1", driveTrainSolenoid1);

		elevatorSpeedController1 = new WPI_VictorSPX(3);
		LiveWindow.addActuator("Elevator", "Speed Controller 1", (WPI_VictorSPX) elevatorSpeedController1);
		elevatorSpeedController1.setInverted(false);
		elevatorSpeedController2 = new WPI_VictorSPX(9);
		LiveWindow.addActuator("Elevator", "Speed Controller 2", (WPI_VictorSPX) elevatorSpeedController2);
		elevatorSpeedController2.setInverted(true);
		
		elevatorSpeedController11 = new VictorSPX(4);
		elevatorSpeedController11.set(ControlMode.Follower, elevatorSpeedController1.getDeviceID());
		elevatorSpeedController11.setInverted(elevatorSpeedController1.getInverted());
		elevatorSpeedController22 = new VictorSPX(10);
		elevatorSpeedController22.set(ControlMode.Follower, elevatorSpeedController2.getDeviceID());
		elevatorSpeedController22.setInverted(elevatorSpeedController2.getInverted());
		
		intakeSpeedController1 = new WPI_VictorSPX(5);
		LiveWindow.addActuator("Intake", "Speed Controller 1", (WPI_VictorSPX) intakeSpeedController1);
		intakeSpeedController1.setInverted(false);
		intakeSpeedController2 = new WPI_VictorSPX(6);
		intakeSpeedController2.setInverted(false);

		elevatorQuadratureEncoder1 = new Encoder(14, 15, true, EncodingType.k4X);
		elevatorQuadratureEncoder1.setDistancePerPulse(1.0);
		elevatorQuadratureEncoder1.setPIDSourceType(PIDSourceType.kRate);

		elevatorDigitalInput1 = new DigitalInput(0);

		armSpeedController1 = new WPI_VictorSPX(6);
		armQuadratureEncoder1 = new Encoder(16, 17, true, EncodingType.k4X);
		armDigitalInput1 = new DigitalInput(1);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	}
}
